<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://lwxn.github.io/posts/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 20 Jan 2021 16:08:28 +0800</lastBuildDate><atom:link href="https://lwxn.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>15 3Sum</title>
      <link>https://lwxn.github.io/posts/15-3sum/</link>
      <pubDate>Wed, 20 Jan 2021 16:08:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/15-3sum/</guid>
      <description>这道题的关键，emm 双指针，然后移来移去，去除重复项，就这样。
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;ans; vector&amp;lt;int&amp;gt;t; int n = nums.size(); if(n &amp;lt; 3) return ans; sort(nums.begin(),nums.end()); for(int i = 0;i&amp;lt;n;i++) { //跳过重复元素  while(i &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; nums.size() &amp;amp;&amp;amp; nums[i] == nums[i-1] ) i++; int j = i+1,k = n-1; while(j&amp;lt;k) { int t = nums[i] +nums[j] + nums[k]; if(t == 0) { ans.push_back({nums[i],nums[j],nums[k]}); j++; k--; while(nums[j] == nums[j-1] &amp;amp;&amp;amp; j &amp;lt; k) j++; while(nums[k] == nums[k+1] &amp;amp;&amp;amp; k &amp;gt; j) k--; } else if(t &amp;gt; 0) { k--; } else { j++; } } } return ans; } }; </description>
    </item>
    
    <item>
      <title>14 Longest Common Prefix</title>
      <link>https://lwxn.github.io/posts/14-longest-common-prefix/</link>
      <pubDate>Tue, 19 Jan 2021 11:16:15 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/14-longest-common-prefix/</guid>
      <description>先排序，后对比前后两个
class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if(strs.size() == 0) return &amp;#34;&amp;#34;; sort(strs.begin(),strs.end()); string s1 = strs.front(),s2 = strs.back(); string ans = &amp;#34;&amp;#34;; for(int i = 0;i&amp;lt;min(s1.size(),s2.size());i++) { if(s1[i] != s2[i]) break; ans += s1[i]; } return ans; } };``` </description>
    </item>
    
    <item>
      <title>13 Roman to Integer</title>
      <link>https://lwxn.github.io/posts/13-roman-to-integer/</link>
      <pubDate>Tue, 19 Jan 2021 10:57:04 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/13-roman-to-integer/</guid>
      <description>class Solution { public: int romanToInt(string s) { int nums1[7] = {1,5,10,50,100,500,1000}; int nums2[6] = {4,9,40,90,400,900}; vector&amp;lt;string&amp;gt;alphas1 = {&amp;#34;I&amp;#34;,&amp;#34;V&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;M&amp;#34;}; vector&amp;lt;string&amp;gt;alphas2 = {&amp;#34;IV&amp;#34;,&amp;#34;IX&amp;#34;,&amp;#34;XL&amp;#34;,&amp;#34;XC&amp;#34;,&amp;#34;CD&amp;#34;,&amp;#34;CM&amp;#34;}; int ans = 0,i = 0; while(i&amp;lt;s.size()) { int flag = 0; if(i+1 &amp;lt; s.size()) { string t = s.substr(i,2); for(int j = 0;j&amp;lt;alphas2.size();j++) { if(t == alphas2[j]) { ans += nums2[j]; i += 2; flag = 1; break; } } } if(!flag) { for(int j = 0;j&amp;lt;alphas1.size();j++) { if(s[i] == alphas1[j][0]) { ans += nums1[j]; i += 1; break; } } } } return ans; } };``` </description>
    </item>
    
    <item>
      <title>12 Integer to Roman</title>
      <link>https://lwxn.github.io/posts/12-integer-to-roman/</link>
      <pubDate>Mon, 18 Jan 2021 21:38:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/12-integer-to-roman/</guid>
      <description>class Solution { public: string intToRoman(int num) { int nums[13] = {1,4,5,9,10,40,50,90,100,400,500,900,1000}; string alphas[13] = {&amp;#34;I&amp;#34;,&amp;#34;IV&amp;#34;,&amp;#34;V&amp;#34;,&amp;#34;IX&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;XL&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;XC&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;CD&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;CM&amp;#34;,&amp;#34;M&amp;#34;},ans = &amp;#34;&amp;#34;; for(int i = 12;i&amp;gt;=0 &amp;amp;&amp;amp; num;i--) { while(num &amp;gt;= nums[i]) { ans = ans + alphas[i]; num -= nums[i]; } } return ans; } };``` </description>
    </item>
    
    <item>
      <title>11 Container With Most Water</title>
      <link>https://lwxn.github.io/posts/11-container-with-most-water/</link>
      <pubDate>Mon, 18 Jan 2021 19:58:27 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/11-container-with-most-water/</guid>
      <description>star
class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int k1 = 0,n = height.size(),k2 = n-1; int Max = 0; int i = 0,j = n-1; while(j&amp;gt;i) { Max = max(Max,min(height[j],height[i])*(j-i)); if(height[i] &amp;lt; height[j]) i++; else j--; } return Max; } };``` 双跳 ```c++ class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int k1 = 0,n = height.size(),k2 = n-1; int Max = 0; int i = 0,j = n-1; while(j&amp;gt;i) { Max = max(Max,min(height[j],height[i])*(j-i)); if(height[i] &amp;lt; height[j]) i++; else if(height[i] &amp;gt; height[j])j--; else{ i++; j--; } } return Max; } }; </description>
    </item>
    
    <item>
      <title>9 Palindrome Number</title>
      <link>https://lwxn.github.io/posts/9-palindrome-number/</link>
      <pubDate>Mon, 18 Jan 2021 18:58:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/9-palindrome-number/</guid>
      <description>class Solution { public: bool isPalindrome(int x) { string s = to_string(x); for(int i = 0;i&amp;lt;s.size();i++) { if(s[i] != s[s.size()-i-1]) return false; } return true; } };``` </description>
    </item>
    
    <item>
      <title>8 String to Integer (Atoi)</title>
      <link>https://lwxn.github.io/posts/8-string-to-integer-atoi/</link>
      <pubDate>Mon, 18 Jan 2021 18:55:04 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/8-string-to-integer-atoi/</guid>
      <description>class Solution { public: int myAtoi(string s) { int i = 0,flag = 0; while(i&amp;lt;s.size() &amp;amp;&amp;amp; s[i] == &amp;#39; &amp;#39;) i++; if(i == s.size() || !(s[i] == &amp;#39;+&amp;#39; || s[i] == &amp;#39;-&amp;#39; || isdigit(s[i]))) return 0; if(s[i] == &amp;#39;+&amp;#39; || s[i] == &amp;#39;-&amp;#39;) { flag = s[i] == &amp;#39;-&amp;#39; ? 1:0; i++; } long ans = 0; while(i&amp;lt;s.size() &amp;amp;&amp;amp; isdigit(s[i])) { ans = ans*10 + s[i] - &amp;#39;0&amp;#39;; if(flag) { if(-ans &amp;gt; INT_MAX) return INT_MAX; if(-ans &amp;lt; INT_MIN) return INT_MIN; } else { if(ans &amp;gt; INT_MAX) return INT_MAX; if(ans &amp;lt; INT_MIN) return INT_MIN; } i++; } ans = flag ?</description>
    </item>
    
    <item>
      <title>7 Reverse Integer</title>
      <link>https://lwxn.github.io/posts/7-reverse-integer/</link>
      <pubDate>Mon, 18 Jan 2021 12:02:41 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/7-reverse-integer/</guid>
      <description>class Solution { public: int reverse(int x) { long X = x; int flag = 0; if(X &amp;lt; 0) { X = -X; flag = 1; } long ans = 0; string s = to_string(X); for(int i = s.size()-1;i&amp;gt;=0;i--) ans = ans*10 + s[i] - &amp;#39;0&amp;#39;; ans = flag ? -ans : ans; int Max = 2147483647; int Min = -2147483648; if(ans &amp;lt;= Max &amp;amp;&amp;amp; ans &amp;gt;= Min) return ans; else return 0; } }; </description>
    </item>
    
    <item>
      <title>6 ZigZag Conversion</title>
      <link>https://lwxn.github.io/posts/6-zigzag-conversion/</link>
      <pubDate>Mon, 18 Jan 2021 11:26:53 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/6-zigzag-conversion/</guid>
      <description>class Solution { public: string convert(string s, int numRows) { if(s.size() == 0) return &amp;#34;&amp;#34;; int n = s.size(); vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;Map(numRows,vector&amp;lt;char&amp;gt;(n,&amp;#39; &amp;#39;)); int mode = 0; int i = 0; int x = -1,y = 0; while(i&amp;lt;n) { //竖排  if(mode == 0) { for(int j = 0;j&amp;lt;numRows &amp;amp;&amp;amp; i&amp;lt;n;j++) { if(j == 0) x++; Map[j][x] = s[i]; y = j; i++; } } else { for(int j = 1;j&amp;lt;numRows-1 &amp;amp;&amp;amp; i&amp;lt;n;j++) { x++; y--; Map[y][x] = s[i]; i++; } } mode = (mode+1)%2; } string ans = &amp;#34;&amp;#34;; for(int i = 0;i&amp;lt;numRows;i++) { for(int j = 0;j&amp;lt;n;j++) { if(Map[i][j] !</description>
    </item>
    
    <item>
      <title>5 Longest Palindromic Substring</title>
      <link>https://lwxn.github.io/posts/5-longest-palindromic-substring/</link>
      <pubDate>Sun, 17 Jan 2021 21:46:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/5-longest-palindromic-substring/</guid>
      <description>dp
class Solution { public: string longestPalindrome(string s) { if(s.size() == 0) return &amp;#34;&amp;#34;; int n = s.size(),ans = 1,l1 = 0,l2 = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;dp(n,vector&amp;lt;int&amp;gt;(n,0)); for(int i = 0;i&amp;lt;n;i++) dp[i][i] = 1; for(int l = 1;l&amp;lt;n;l++) { for(int i = 0;i&amp;lt;n-l;i++) { int j = i+l; if(j == i+1) { dp[i][j] = s[i] == s[j] ? 2 : 0; } else { if(dp[i+1][j-1] &amp;amp;&amp;amp; s[i] == s[j]) dp[i][j] = dp[i+1][j-1] + 2; } if(ans &amp;lt; dp[i][j]) { ans = dp[i][j]; l1 = i; l2 = j; } } } return s.</description>
    </item>
    
    <item>
      <title>4 Median of Two Sorted Arrays</title>
      <link>https://lwxn.github.io/posts/4-median-of-two-sorted-arrays/</link>
      <pubDate>Sun, 17 Jan 2021 20:43:45 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/4-median-of-two-sorted-arrays/</guid>
      <description>class Solution { public: double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); int k1,k2; //odd  if( (m+n)%2 == 0) { k1 = (m+n)/2; k2 = k1-1; } else { k1 = (m+n)/2; k2 = k1; } int i = 0,j = 0; int temp = 0; int t = 0; while(i&amp;lt;nums1.size() &amp;amp;&amp;amp; j &amp;lt;nums2.size()) { if(nums1[i] &amp;lt;= nums2[j]) { if(t == k1) temp += nums1[i]; if(t == k2) temp += nums1[i]; i++; } else { if(t == k1) temp += nums2[j]; if(t == k2) temp += nums2[j]; j++; } t++; } while(i&amp;lt;nums1.</description>
    </item>
    
    <item>
      <title>3 Longest Substring Without Repeating Characters</title>
      <link>https://lwxn.github.io/posts/3-longest-substring-without-repeating-characters/</link>
      <pubDate>Sun, 17 Jan 2021 20:26:46 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/3-longest-substring-without-repeating-characters/</guid>
      <description>滑动窗口
class Solution { public: int lengthOfLongestSubstring(string s) { int ans = 0,i = 0,j = 1; if(s.size() == 1) ans = 1; unordered_map&amp;lt;char,int&amp;gt;Map; Map[s[i]] = i; while(i&amp;lt;s.size() &amp;amp;&amp;amp; j&amp;lt;s.size()) { auto it = Map.find(s[j]); if(it != Map.end() &amp;amp;&amp;amp; it-&amp;gt;second &amp;gt;= i) { ans = max(ans,j-i); i = Map[s[j]] + 1; } else { Map[s[j]] = j; ans = max(ans,j-i+1); j++; } } return ans; } }; </description>
    </item>
    
    <item>
      <title>2 Add Two Numbers</title>
      <link>https://lwxn.github.io/posts/2-add-two-numbers/</link>
      <pubDate>Sun, 17 Jan 2021 20:00:32 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/2-add-two-numbers/</guid>
      <description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *p = new ListNode(0); ListNode *head = p; int c = 0; while(l1 &amp;amp;&amp;amp; l2) { int r = (l1-&amp;gt;val + l2-&amp;gt;val + c) %10; c = (l1-&amp;gt;val + l2-&amp;gt;val + c)/10; p-&amp;gt;next = new ListNode(r); p = p-&amp;gt;next; l1 = l1-&amp;gt;next; l2 = l2-&amp;gt;next; } while(l1) { int r = (l1-&amp;gt;val + c)%10; c = (l1-&amp;gt;val + c)/10; p-&amp;gt;next = new ListNode(r); p = p-&amp;gt;next; l1 = l1-&amp;gt;next; } while(l2) { int r = (l2-&amp;gt;val + c)%10; c = (l2-&amp;gt;val + c)/10; p-&amp;gt;next = new ListNode(r); p = p-&amp;gt;next; l2 = l2-&amp;gt;next; } if(c) { p-&amp;gt;next = new ListNode(c); } return head-&amp;gt;next; } }; &amp;#39;&amp;#39;&amp;#39; </description>
    </item>
    
    <item>
      <title>1 Two Sum</title>
      <link>https://lwxn.github.io/posts/1-two-sum/</link>
      <pubDate>Sun, 17 Jan 2021 19:45:03 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/1-two-sum/</guid>
      <description>第一种暴力解：
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;ans; for(int i = 0;i&amp;lt;nums.size();i++) { for(int j = i+1;j&amp;lt;nums.size();j++) { if(nums[i] + nums[j] == target) { ans.push_back(i); ans.push_back(j); return ans; } } } return ans; } }; 第二种，使用hashmap
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int,int&amp;gt;Map; vector&amp;lt;int&amp;gt;ans; for(int i = 0;i&amp;lt;nums.size();i++) { auto it = Map.find(target-nums[i]); if(it != Map.end()) { return {i,it-&amp;gt;second}; } Map[nums[i]] = i; } return ans; } }; </description>
    </item>
    
    <item>
      <title>Hi，this is lwxn&#39;s blog</title>
      <link>https://lwxn.github.io/posts/introduction/</link>
      <pubDate>Fri, 08 Jan 2021 09:37:04 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/introduction/</guid>
      <description>很高兴你可以看到我的小岛~</description>
    </item>
    
    <item>
      <title>今天好难过</title>
      <link>https://lwxn.github.io/posts/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/</link>
      <pubDate>Thu, 07 Jan 2021 19:44:30 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/</guid>
      <description>一点点内心想法：
2021/1/8：
昨天梦见下雪了，真是可笑，广州这种地方是不会下雪的。但是睡梦中隐隐约约听见了风怒吼着卷动树叶的声音，像是冬天终于迎来了它的征程。这地方终于有了点冬天的味道，不是吗。
2021/1/15：
今天去医院了，emmmmm</description>
    </item>
    
  </channel>
</rss>
