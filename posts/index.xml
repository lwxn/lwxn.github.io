<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My New Hugo Site</title>
    <link>https://lwxn.github.io/posts/</link>
    <description>Recent content in Posts on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 22 Jan 2021 14:53:02 +0800</lastBuildDate><atom:link href="https://lwxn.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>28 Implement StrStr()</title>
      <link>https://lwxn.github.io/posts/28-implement-strstr/</link>
      <pubDate>Fri, 22 Jan 2021 14:53:02 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/28-implement-strstr/</guid>
      <description>class Solution { public: int strStr(string haystack, string needle) { int n = needle.size(); if(!n) return 0; for(int i = 0;i&amp;lt;haystack.size();i++) { if(i + n - 1 &amp;lt; haystack.size()) { if(haystack.substr(i,n) == needle) return i; } else { return -1; } } return -1; } }; </description>
    </item>
    
    <item>
      <title>27 Remove Element</title>
      <link>https://lwxn.github.io/posts/27-remove-element/</link>
      <pubDate>Fri, 22 Jan 2021 14:47:39 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/27-remove-element/</guid>
      <description>class Solution { public: int removeElement(vector&amp;lt;int&amp;gt;&amp;amp; nums, int val) { if(nums.size() == 0) return 0; int i = 0,j = 0; while(j&amp;lt;nums.size()) { while(i&amp;lt;nums.size() &amp;amp;&amp;amp; nums[i] != val) i++; j = j &amp;lt;= i ? i+1 : j; while(j&amp;lt;nums.size() &amp;amp;&amp;amp; nums[j] == val) j++; if(i &amp;lt; nums.size() &amp;amp;&amp;amp; j&amp;lt; nums.size()) { swap(nums[i],nums[j]); i++; j++; } else break; } return i; } };``` </description>
    </item>
    
    <item>
      <title>26 Remove Duplicates From Sorted Array</title>
      <link>https://lwxn.github.io/posts/26-remove-duplicates-from-sorted-array/</link>
      <pubDate>Fri, 22 Jan 2021 14:02:59 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/26-remove-duplicates-from-sorted-array/</guid>
      <description>class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size() == 0) return 0; int i = 0,j = 1; while(j&amp;lt;nums.size()) { while(j&amp;lt;nums.size()&amp;amp;&amp;amp;nums[j] == nums[i]) j++; if(j&amp;lt;nums.size()) { nums[++i] = nums[j++]; } } return i+1; } };``` </description>
    </item>
    
    <item>
      <title>25 Reverse Nodes in K Group</title>
      <link>https://lwxn.github.io/posts/25-reverse-nodes-in-k-group/</link>
      <pubDate>Fri, 22 Jan 2021 13:45:50 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/25-reverse-nodes-in-k-group/</guid>
      <description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: void print(ListNode* link) { ListNode* p = link; while(p) { cout&amp;lt;&amp;lt;p-&amp;gt;val&amp;lt;&amp;lt;&amp;#34; &amp;#34;; p = p-&amp;gt;next; } cout&amp;lt;&amp;lt;endl; } ListNode* reverse(ListNode* head) { ListNode* p = head,*prev = p-&amp;gt;next; while(prev) { ListNode* r = prev-&amp;gt;next; prev-&amp;gt;next = p; p = prev; prev = r; } head-&amp;gt;next = nullptr; return p; } ListNode* reverseKGroup(ListNode* head, int k) { ListNode* H = new ListNode(0); H-&amp;gt;next = head; ListNode* p = H,*tail = nullptr; while(p) { int flag = 0; tail = p; for(int i = 0;i&amp;lt;k;i++) { tail = tail-&amp;gt;next; if(!</description>
    </item>
    
    <item>
      <title>24 Swap Nodes in Pairs</title>
      <link>https://lwxn.github.io/posts/24-swap-nodes-in-pairs/</link>
      <pubDate>Fri, 22 Jan 2021 12:37:02 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/24-swap-nodes-in-pairs/</guid>
      <description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode * H = new ListNode(0); H-&amp;gt;next = head; ListNode *b = H,* p = head,*r = nullptr,*e = nullptr; while(p) { r = p-&amp;gt;next; if(!</description>
    </item>
    
    <item>
      <title>23 Merge K Sorted Lists</title>
      <link>https://lwxn.github.io/posts/23-merge-k-sorted-lists/</link>
      <pubDate>Thu, 21 Jan 2021 21:34:34 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/23-merge-k-sorted-lists/</guid>
      <description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: const static int cmp(const int a,const int b) { return a &amp;lt; b; } ListNode* mergeKLists(vector&amp;lt;ListNode*&amp;gt;&amp;amp; lists) { vector&amp;lt;int&amp;gt;list; ListNode* p = nullptr; for(ListNode* p : lists) { while(p) { ListNode* t = p; p = p-&amp;gt;next; t-&amp;gt;next = nullptr; list.</description>
    </item>
    
    <item>
      <title>22 Generate Parentheses</title>
      <link>https://lwxn.github.io/posts/22-generate-parentheses/</link>
      <pubDate>Thu, 21 Jan 2021 21:23:23 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/22-generate-parentheses/</guid>
      <description>class Solution { public: vector&amp;lt;string&amp;gt;ans; char c[2] = {&amp;#39;(&amp;#39;,&amp;#39;)&amp;#39;}; vector&amp;lt;string&amp;gt; generateParenthesis(int n) { if(!n) return ans; int left = 0,right = 0; dfs(&amp;#34;(&amp;#34;,1,n,n-1,n); return ans; } void dfs(string s,int begin,int n,int left,int right) { if(s.size() == 2*n &amp;amp;&amp;amp; !left &amp;amp;&amp;amp; !right) { ans.push_back(s); return; } for(int i = 0;i&amp;lt;2;i++) { //left  if(i == 0) { if(left) { s.push_back(c[i]); // cout&amp;lt;&amp;lt;s&amp;lt;&amp;lt;endl;  dfs(s,begin+1,n,left-1,right); s.pop_back(); } }//right  else { if(right &amp;gt; left) { s.</description>
    </item>
    
    <item>
      <title>21 Merge Two Sorted Lists</title>
      <link>https://lwxn.github.io/posts/21-merge-two-sorted-lists/</link>
      <pubDate>Thu, 21 Jan 2021 21:05:18 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/21-merge-two-sorted-lists/</guid>
      <description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* head = new ListNode(0),*p = head; while(l1 &amp;amp;&amp;amp; l2) { if(l1-&amp;gt;val &amp;lt; l2-&amp;gt;val) { p-&amp;gt;next = l1; l1 = l1-&amp;gt;next; } else { p-&amp;gt;next = l2; l2 = l2-&amp;gt;next; } p = p-&amp;gt;next; } if(l1) p-&amp;gt;next = l1; if(l2) p-&amp;gt;next = l2; return head-&amp;gt;next; } };``` </description>
    </item>
    
    <item>
      <title>20 Valid Parentheses</title>
      <link>https://lwxn.github.io/posts/20-valid-parentheses/</link>
      <pubDate>Thu, 21 Jan 2021 20:47:10 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/20-valid-parentheses/</guid>
      <description>class Solution { public: bool isValid(string s) { stack&amp;lt;char&amp;gt;ss; for(int i = 0;i&amp;lt;s.size();i++) { if(s[i] == &amp;#39;(&amp;#39; || s[i] == &amp;#39;[&amp;#39; || s[i] == &amp;#39;{&amp;#39;) { ss.push(s[i]); } else { if(s[i] == &amp;#39;)&amp;#39;) { if(!ss.empty()&amp;amp;&amp;amp;ss.top() == &amp;#39;(&amp;#39;) ss.pop(); else return false; } if(s[i] == &amp;#39;}&amp;#39;) { if(!ss.empty()&amp;amp;&amp;amp;ss.top() == &amp;#39;{&amp;#39;) ss.pop(); else return false; } if(s[i] == &amp;#39;]&amp;#39;) { if(!ss.empty()&amp;amp;&amp;amp;ss.top() == &amp;#39;[&amp;#39;) ss.pop(); else return false; } } } return ss.empty(); } };``` </description>
    </item>
    
    <item>
      <title>19 Remove Nth Node From End of List</title>
      <link>https://lwxn.github.io/posts/19-remove-nth-node-from-end-of-list/</link>
      <pubDate>Thu, 21 Jan 2021 20:35:12 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/19-remove-nth-node-from-end-of-list/</guid>
      <description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* p = head; int len = 0; while(p) { p = p-&amp;gt;next; len++; } len = len - n; ListNode* ans = new ListNode(0,head); ListNode* b = ans,*r = nullptr; p = head; r = p-&amp;gt;next; while(len) { b = p; p = p-&amp;gt;next; r = r-&amp;gt;next; len --; } b-&amp;gt;next = r; p-&amp;gt;next = nullptr; return ans-&amp;gt;next; } }; </description>
    </item>
    
    <item>
      <title>18 4Sum</title>
      <link>https://lwxn.github.io/posts/18-4sum/</link>
      <pubDate>Thu, 21 Jan 2021 20:24:45 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/18-4sum/</guid>
      <description>三数之和加个循环
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;ans; sort(nums.begin(),nums.end()); int n = nums.size(); for(int l = 0;l&amp;lt;n;l++) { while(l != 0 &amp;amp;&amp;amp; l&amp;lt;n &amp;amp;&amp;amp; nums[l] == nums[l-1]) l++; for(int i = l+1;i&amp;lt;n;i++) { while(i != l+1 &amp;amp;&amp;amp; i&amp;lt;n &amp;amp;&amp;amp; nums[i] == nums[i-1]) i++; int j = i + 1; int k = n - 1; while(j&amp;lt;k) { int t = nums[i] + nums[j] +nums[k] + nums[l]; if(t == target) { ans.</description>
    </item>
    
    <item>
      <title>17 Letter Combinations of a Phone Number</title>
      <link>https://lwxn.github.io/posts/17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Thu, 21 Jan 2021 20:01:06 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/17-letter-combinations-of-a-phone-number/</guid>
      <description>class Solution { public: vector&amp;lt;string&amp;gt;ans; vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;num = {{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;},{&#39;d&#39;,&#39;e&#39;,&#39;f&#39;}, {&#39;g&#39;,&#39;h&#39;,&#39;i&#39;},{&#39;j&#39;,&#39;k&#39;,&#39;l&#39;},{&#39;m&#39;,&#39;n&#39;,&#39;o&#39;},{&#39;p&#39;,&#39;q&#39;,&#39;r&#39;,&#39;s&#39;}, {&#39;t&#39;,&#39;u&#39;,&#39;v&#39;},{&#39;w&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;}}; vector&amp;lt;string&amp;gt; letterCombinations(string digits) { if(digits.size() == 0) return ans; string s = &amp;quot;&amp;quot;; dfs(s,0,digits); return ans; } void dfs(string s,int begin,string digits) { if(begin == digits.size()) { ans.push_back(s); return; } int t = digits[begin] - &#39;2&#39;; for(char c : num[t]) { s.push_back(c); dfs(s,begin+1,digits); s.pop_back(); } } };``` </description>
    </item>
    
    <item>
      <title>16 3Sum Closest</title>
      <link>https://lwxn.github.io/posts/16-3sum-closest/</link>
      <pubDate>Thu, 21 Jan 2021 19:39:29 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/16-3sum-closest/</guid>
      <description>这道题蛮简单的，双指针走起
class Solution { public: int threeSumClosest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { sort(nums.begin(),nums.end()); int n = nums.size(); int tmp = nums[0] + nums[1] +nums[2]; for(int i = 0;i&amp;lt;n;i++) { while(i != 0 &amp;amp;&amp;amp; i&amp;lt;n &amp;amp;&amp;amp; nums[i] == nums[i-1]) i++; int j = i + 1; int k = n - 1; while(j&amp;lt;k) { int t = nums[i] + nums[j] +nums[k]; if(abs(t - target) &amp;lt; abs(tmp - target)) { tmp = t; } if(t &amp;gt; target &amp;amp;&amp;amp; j&amp;lt;k) k--; else if(t &amp;lt; target &amp;amp;&amp;amp; j&amp;lt;k) j++; else{ return t; } } } return tmp; } };``` </description>
    </item>
    
    <item>
      <title>15 3Sum</title>
      <link>https://lwxn.github.io/posts/15-3sum/</link>
      <pubDate>Wed, 20 Jan 2021 16:08:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/15-3sum/</guid>
      <description>这道题的关键，emm 双指针，然后移来移去，去除重复项，就这样。
class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;ans; vector&amp;lt;int&amp;gt;t; int n = nums.size(); if(n &amp;lt; 3) return ans; sort(nums.begin(),nums.end()); for(int i = 0;i&amp;lt;n;i++) { //跳过重复元素  while(i &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; nums.size() &amp;amp;&amp;amp; nums[i] == nums[i-1] ) i++; int j = i+1,k = n-1; while(j&amp;lt;k) { int t = nums[i] +nums[j] + nums[k]; if(t == 0) { ans.push_back({nums[i],nums[j],nums[k]}); j++; k--; while(nums[j] == nums[j-1] &amp;amp;&amp;amp; j &amp;lt; k) j++; while(nums[k] == nums[k+1] &amp;amp;&amp;amp; k &amp;gt; j) k--; } else if(t &amp;gt; 0) { k--; } else { j++; } } } return ans; } }; </description>
    </item>
    
    <item>
      <title>14 Longest Common Prefix</title>
      <link>https://lwxn.github.io/posts/14-longest-common-prefix/</link>
      <pubDate>Tue, 19 Jan 2021 11:16:15 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/14-longest-common-prefix/</guid>
      <description>先排序，后对比前后两个
class Solution { public: string longestCommonPrefix(vector&amp;lt;string&amp;gt;&amp;amp; strs) { if(strs.size() == 0) return &amp;#34;&amp;#34;; sort(strs.begin(),strs.end()); string s1 = strs.front(),s2 = strs.back(); string ans = &amp;#34;&amp;#34;; for(int i = 0;i&amp;lt;min(s1.size(),s2.size());i++) { if(s1[i] != s2[i]) break; ans += s1[i]; } return ans; } };``` </description>
    </item>
    
    <item>
      <title>13 Roman to Integer</title>
      <link>https://lwxn.github.io/posts/13-roman-to-integer/</link>
      <pubDate>Tue, 19 Jan 2021 10:57:04 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/13-roman-to-integer/</guid>
      <description>class Solution { public: int romanToInt(string s) { int nums1[7] = {1,5,10,50,100,500,1000}; int nums2[6] = {4,9,40,90,400,900}; vector&amp;lt;string&amp;gt;alphas1 = {&amp;#34;I&amp;#34;,&amp;#34;V&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;M&amp;#34;}; vector&amp;lt;string&amp;gt;alphas2 = {&amp;#34;IV&amp;#34;,&amp;#34;IX&amp;#34;,&amp;#34;XL&amp;#34;,&amp;#34;XC&amp;#34;,&amp;#34;CD&amp;#34;,&amp;#34;CM&amp;#34;}; int ans = 0,i = 0; while(i&amp;lt;s.size()) { int flag = 0; if(i+1 &amp;lt; s.size()) { string t = s.substr(i,2); for(int j = 0;j&amp;lt;alphas2.size();j++) { if(t == alphas2[j]) { ans += nums2[j]; i += 2; flag = 1; break; } } } if(!flag) { for(int j = 0;j&amp;lt;alphas1.size();j++) { if(s[i] == alphas1[j][0]) { ans += nums1[j]; i += 1; break; } } } } return ans; } };``` </description>
    </item>
    
    <item>
      <title>12 Integer to Roman</title>
      <link>https://lwxn.github.io/posts/12-integer-to-roman/</link>
      <pubDate>Mon, 18 Jan 2021 21:38:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/12-integer-to-roman/</guid>
      <description>class Solution { public: string intToRoman(int num) { int nums[13] = {1,4,5,9,10,40,50,90,100,400,500,900,1000}; string alphas[13] = {&amp;#34;I&amp;#34;,&amp;#34;IV&amp;#34;,&amp;#34;V&amp;#34;,&amp;#34;IX&amp;#34;,&amp;#34;X&amp;#34;,&amp;#34;XL&amp;#34;,&amp;#34;L&amp;#34;,&amp;#34;XC&amp;#34;,&amp;#34;C&amp;#34;,&amp;#34;CD&amp;#34;,&amp;#34;D&amp;#34;,&amp;#34;CM&amp;#34;,&amp;#34;M&amp;#34;},ans = &amp;#34;&amp;#34;; for(int i = 12;i&amp;gt;=0 &amp;amp;&amp;amp; num;i--) { while(num &amp;gt;= nums[i]) { ans = ans + alphas[i]; num -= nums[i]; } } return ans; } };``` </description>
    </item>
    
    <item>
      <title>11 Container With Most Water</title>
      <link>https://lwxn.github.io/posts/11-container-with-most-water/</link>
      <pubDate>Mon, 18 Jan 2021 19:58:27 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/11-container-with-most-water/</guid>
      <description>star
class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int k1 = 0,n = height.size(),k2 = n-1; int Max = 0; int i = 0,j = n-1; while(j&amp;gt;i) { Max = max(Max,min(height[j],height[i])*(j-i)); if(height[i] &amp;lt; height[j]) i++; else j--; } return Max; } };``` 双跳 ```c++ class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int k1 = 0,n = height.size(),k2 = n-1; int Max = 0; int i = 0,j = n-1; while(j&amp;gt;i) { Max = max(Max,min(height[j],height[i])*(j-i)); if(height[i] &amp;lt; height[j]) i++; else if(height[i] &amp;gt; height[j])j--; else{ i++; j--; } } return Max; } }; </description>
    </item>
    
    <item>
      <title>9 Palindrome Number</title>
      <link>https://lwxn.github.io/posts/9-palindrome-number/</link>
      <pubDate>Mon, 18 Jan 2021 18:58:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/9-palindrome-number/</guid>
      <description>class Solution { public: bool isPalindrome(int x) { string s = to_string(x); for(int i = 0;i&amp;lt;s.size();i++) { if(s[i] != s[s.size()-i-1]) return false; } return true; } };``` </description>
    </item>
    
    <item>
      <title>8 String to Integer (Atoi)</title>
      <link>https://lwxn.github.io/posts/8-string-to-integer-atoi/</link>
      <pubDate>Mon, 18 Jan 2021 18:55:04 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/8-string-to-integer-atoi/</guid>
      <description>class Solution { public: int myAtoi(string s) { int i = 0,flag = 0; while(i&amp;lt;s.size() &amp;amp;&amp;amp; s[i] == &amp;#39; &amp;#39;) i++; if(i == s.size() || !(s[i] == &amp;#39;+&amp;#39; || s[i] == &amp;#39;-&amp;#39; || isdigit(s[i]))) return 0; if(s[i] == &amp;#39;+&amp;#39; || s[i] == &amp;#39;-&amp;#39;) { flag = s[i] == &amp;#39;-&amp;#39; ? 1:0; i++; } long ans = 0; while(i&amp;lt;s.size() &amp;amp;&amp;amp; isdigit(s[i])) { ans = ans*10 + s[i] - &amp;#39;0&amp;#39;; if(flag) { if(-ans &amp;gt; INT_MAX) return INT_MAX; if(-ans &amp;lt; INT_MIN) return INT_MIN; } else { if(ans &amp;gt; INT_MAX) return INT_MAX; if(ans &amp;lt; INT_MIN) return INT_MIN; } i++; } ans = flag ?</description>
    </item>
    
    <item>
      <title>7 Reverse Integer</title>
      <link>https://lwxn.github.io/posts/7-reverse-integer/</link>
      <pubDate>Mon, 18 Jan 2021 12:02:41 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/7-reverse-integer/</guid>
      <description>class Solution { public: int reverse(int x) { long X = x; int flag = 0; if(X &amp;lt; 0) { X = -X; flag = 1; } long ans = 0; string s = to_string(X); for(int i = s.size()-1;i&amp;gt;=0;i--) ans = ans*10 + s[i] - &amp;#39;0&amp;#39;; ans = flag ? -ans : ans; int Max = 2147483647; int Min = -2147483648; if(ans &amp;lt;= Max &amp;amp;&amp;amp; ans &amp;gt;= Min) return ans; else return 0; } }; </description>
    </item>
    
    <item>
      <title>6 ZigZag Conversion</title>
      <link>https://lwxn.github.io/posts/6-zigzag-conversion/</link>
      <pubDate>Mon, 18 Jan 2021 11:26:53 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/6-zigzag-conversion/</guid>
      <description>class Solution { public: string convert(string s, int numRows) { if(s.size() == 0) return &amp;#34;&amp;#34;; int n = s.size(); vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;Map(numRows,vector&amp;lt;char&amp;gt;(n,&amp;#39; &amp;#39;)); int mode = 0; int i = 0; int x = -1,y = 0; while(i&amp;lt;n) { //竖排  if(mode == 0) { for(int j = 0;j&amp;lt;numRows &amp;amp;&amp;amp; i&amp;lt;n;j++) { if(j == 0) x++; Map[j][x] = s[i]; y = j; i++; } } else { for(int j = 1;j&amp;lt;numRows-1 &amp;amp;&amp;amp; i&amp;lt;n;j++) { x++; y--; Map[y][x] = s[i]; i++; } } mode = (mode+1)%2; } string ans = &amp;#34;&amp;#34;; for(int i = 0;i&amp;lt;numRows;i++) { for(int j = 0;j&amp;lt;n;j++) { if(Map[i][j] !</description>
    </item>
    
    <item>
      <title>5 Longest Palindromic Substring</title>
      <link>https://lwxn.github.io/posts/5-longest-palindromic-substring/</link>
      <pubDate>Sun, 17 Jan 2021 21:46:28 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/5-longest-palindromic-substring/</guid>
      <description>dp
class Solution { public: string longestPalindrome(string s) { if(s.size() == 0) return &amp;#34;&amp;#34;; int n = s.size(),ans = 1,l1 = 0,l2 = 0; vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;dp(n,vector&amp;lt;int&amp;gt;(n,0)); for(int i = 0;i&amp;lt;n;i++) dp[i][i] = 1; for(int l = 1;l&amp;lt;n;l++) { for(int i = 0;i&amp;lt;n-l;i++) { int j = i+l; if(j == i+1) { dp[i][j] = s[i] == s[j] ? 2 : 0; } else { if(dp[i+1][j-1] &amp;amp;&amp;amp; s[i] == s[j]) dp[i][j] = dp[i+1][j-1] + 2; } if(ans &amp;lt; dp[i][j]) { ans = dp[i][j]; l1 = i; l2 = j; } } } return s.</description>
    </item>
    
    <item>
      <title>4 Median of Two Sorted Arrays</title>
      <link>https://lwxn.github.io/posts/4-median-of-two-sorted-arrays/</link>
      <pubDate>Sun, 17 Jan 2021 20:43:45 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/4-median-of-two-sorted-arrays/</guid>
      <description>class Solution { public: double findMedianSortedArrays(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); int k1,k2; //odd  if( (m+n)%2 == 0) { k1 = (m+n)/2; k2 = k1-1; } else { k1 = (m+n)/2; k2 = k1; } int i = 0,j = 0; int temp = 0; int t = 0; while(i&amp;lt;nums1.size() &amp;amp;&amp;amp; j &amp;lt;nums2.size()) { if(nums1[i] &amp;lt;= nums2[j]) { if(t == k1) temp += nums1[i]; if(t == k2) temp += nums1[i]; i++; } else { if(t == k1) temp += nums2[j]; if(t == k2) temp += nums2[j]; j++; } t++; } while(i&amp;lt;nums1.</description>
    </item>
    
    <item>
      <title>3 Longest Substring Without Repeating Characters</title>
      <link>https://lwxn.github.io/posts/3-longest-substring-without-repeating-characters/</link>
      <pubDate>Sun, 17 Jan 2021 20:26:46 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/3-longest-substring-without-repeating-characters/</guid>
      <description>滑动窗口
class Solution { public: int lengthOfLongestSubstring(string s) { int ans = 0,i = 0,j = 1; if(s.size() == 1) ans = 1; unordered_map&amp;lt;char,int&amp;gt;Map; Map[s[i]] = i; while(i&amp;lt;s.size() &amp;amp;&amp;amp; j&amp;lt;s.size()) { auto it = Map.find(s[j]); if(it != Map.end() &amp;amp;&amp;amp; it-&amp;gt;second &amp;gt;= i) { ans = max(ans,j-i); i = Map[s[j]] + 1; } else { Map[s[j]] = j; ans = max(ans,j-i+1); j++; } } return ans; } }; </description>
    </item>
    
    <item>
      <title>2 Add Two Numbers</title>
      <link>https://lwxn.github.io/posts/2-add-two-numbers/</link>
      <pubDate>Sun, 17 Jan 2021 20:00:32 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/2-add-two-numbers/</guid>
      <description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode *p = new ListNode(0); ListNode *head = p; int c = 0; while(l1 &amp;amp;&amp;amp; l2) { int r = (l1-&amp;gt;val + l2-&amp;gt;val + c) %10; c = (l1-&amp;gt;val + l2-&amp;gt;val + c)/10; p-&amp;gt;next = new ListNode(r); p = p-&amp;gt;next; l1 = l1-&amp;gt;next; l2 = l2-&amp;gt;next; } while(l1) { int r = (l1-&amp;gt;val + c)%10; c = (l1-&amp;gt;val + c)/10; p-&amp;gt;next = new ListNode(r); p = p-&amp;gt;next; l1 = l1-&amp;gt;next; } while(l2) { int r = (l2-&amp;gt;val + c)%10; c = (l2-&amp;gt;val + c)/10; p-&amp;gt;next = new ListNode(r); p = p-&amp;gt;next; l2 = l2-&amp;gt;next; } if(c) { p-&amp;gt;next = new ListNode(c); } return head-&amp;gt;next; } }; &amp;#39;&amp;#39;&amp;#39; </description>
    </item>
    
    <item>
      <title>1 Two Sum</title>
      <link>https://lwxn.github.io/posts/1-two-sum/</link>
      <pubDate>Sun, 17 Jan 2021 19:45:03 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/1-two-sum/</guid>
      <description>第一种暴力解：
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { vector&amp;lt;int&amp;gt;ans; for(int i = 0;i&amp;lt;nums.size();i++) { for(int j = i+1;j&amp;lt;nums.size();j++) { if(nums[i] + nums[j] == target) { ans.push_back(i); ans.push_back(j); return ans; } } } return ans; } }; 第二种，使用hashmap
class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { unordered_map&amp;lt;int,int&amp;gt;Map; vector&amp;lt;int&amp;gt;ans; for(int i = 0;i&amp;lt;nums.size();i++) { auto it = Map.find(target-nums[i]); if(it != Map.end()) { return {i,it-&amp;gt;second}; } Map[nums[i]] = i; } return ans; } }; </description>
    </item>
    
    <item>
      <title>Hi，this is lwxn&#39;s blog</title>
      <link>https://lwxn.github.io/posts/introduction/</link>
      <pubDate>Fri, 08 Jan 2021 09:37:04 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/introduction/</guid>
      <description>很高兴你可以看到我的小岛~</description>
    </item>
    
    <item>
      <title>今天好难过</title>
      <link>https://lwxn.github.io/posts/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/</link>
      <pubDate>Thu, 07 Jan 2021 19:44:30 +0800</pubDate>
      
      <guid>https://lwxn.github.io/posts/%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/</guid>
      <description>一点点内心想法：
2021/1/8：
昨天梦见下雪了，真是可笑，广州这种地方是不会下雪的。但是睡梦中隐隐约约听见了风怒吼着卷动树叶的声音，像是冬天终于迎来了它的征程。这地方终于有了点冬天的味道，不是吗。
2021/1/15：
今天去医院了，emmmmm</description>
    </item>
    
  </channel>
</rss>
